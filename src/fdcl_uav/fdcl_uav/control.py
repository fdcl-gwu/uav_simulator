from .matrix_utils import hat, vee, deriv_unit_vector, saturate
from .integral_utils import IntegralError, IntegralErrorVec3

import datetime
import numpy as np

import rclpy
from rclpy.node import Node

from geometry_msgs.msg import Vector3, WrenchStamped
from std_msgs.msg import Int32, Bool

from uav_gazebo.msg import DesiredData, ErrorData, ModeData, StateData


class ControlNode(Node):
    """Controller for the UAV trajectory tracking.

    This class detemines the control outputs for a quadrotor UAV given it's
    current state and the desired states.

    Attributes:
        t0: (datetime object) time at epoch
        t: (float) current time since epoch [s]
        t_prev: (float) time since epoch in the previous loop [s]
        dt: (float) time difference between two calls to the controller [s]

        x: (3x1 numpy array) current position of the UAV [m]
        v: (3x1 numpy array) current velocity of the UAV [m/s]
        a: (3x1 numpy array) current acceleration of the UAV [m/s^s]
        R: (3x3 numpy array) current attitude of the UAV in SO(3)
        W: (3x1 numpy array) current angular velocity of the UAV [rad/s]

        xd: (3x1 numpy array) desired position of the UAV [m]
        xd_dot: (3x1 numpy array) desired velocity of the UAV [m/s]
        xd_2dot: (3x1 numpy array) desired accleration of the UAV [m/s^2]
        xd_3dot: (3x1 numpy array) desired third derivative of the UAV 
            position [m/s^3]
        xd_4dot: (3x1 numpy array) desired fourth derivative of the UAV 
            position [m/s^4]

        b1d: (3x1 numpy array) desired direction of the first body axis
        b1d_dot: (3x1 numpy array) first time derivative of the desired  
            direction of the first body axis
        b1d_2dot: (3x1 numpy array) second time desired direction of the first 
            body axis

        Wd: (3x1 numpy array) desired body angular velocity [rad/s]
        Wd_dot: (3x1 numpy array) desired body angular acceleration [rad/s^2]

        Rd: (3x3 numpy array) desired attitude in SO(3)

        b3d: (3x1 numpy array) desired direction of the third body axis
        b3d_dot: (3x1 numpy array)  first time derivative of the desired  
            direction of the third body axis
        b3d_2dot: (3x1 numpy array)  second time desired direction of the third 
            body axis

        b1c: (3x1 numpy array) calculated direction of the first body axis
        wc3: (float) angular velocity around third body axis [rad/s]
        wc3_dot: (float) angular acceleration around third body axis [rad/s^s]

        use_integral: (bool) flag to enable/disable integral control 

        e1 = (3x1 numpy array) direction of the e1 axis
        e2 = (3x1 numpy array) direction of the e2 axis
        e3 = (3x1 numpy array) direction of the e3 axis

        m: (float) mass of the rover [kg]
        g: (float) gravitational acceleration [m/s^2]
        c_tf: (float) torsional moment generated by the propellers
        l: (float) length of the rover arm [m]
        J: (3x3 numpy array) inertia matrix of the rover

        kR: (3x3 numpy array) attitude gains
        kW: (3x3 numpy array) angular rate gains

        ky: (float) yaw gain for decoupled-yaw controller
        kwy: (float) yaw angular rate gain for decoupled-yaw controller

        kX: (3x3 numpy array) position gains
        kV: (3x3 numpy array) velocity gains

        kIR: (float) attitude integral gain
        ki: (float) position integral gain
        kI: (float) ttitude integral gain for roll and pitch
        kyI: (float) attitude integral gain for yaw
        kIX: (float) position integral gains
        c1: (float) parameters for decoupled-yaw integral control
        c2: (float) parameters for decoupled-yaw integral control
        c3: (float) parameters for decoupled-yaw integral control

        fM: (4x1 numpy array) force-moment vector
        f_total: (float) calculated forces required by each moter

        fM_to_forces: (4x4 numpy array) force to force-moment conversion
            matrix
        fM_to_forces_inv: (4x4 numpy array) force-moment to force conversion
            matrix

        eIX: (IntegralErrorVec3) position integral error
        eIR: (IntegralErrorVec3) attitude integral error
        eI1: (IntegralError) attitude integral error for roll axis
        eI2: (IntegralError) attitude integral error for pitch axis
        eIy: (IntegralError) attitude integral error for yaw axis
        eIX: (IntegralError) position integral error

        sat_sigma
    """

    def __init__(self):
        Node.__init__(self, 'control')

        self.t0 = self.get_clock().now()
        self.t = 0.0
        self.t_pre = 0.0
        self.dt = 1e-9

        # Current state
        self.x = np.zeros(3)
        self.v = np.zeros(3)
        self.a = np.zeros(3)
        self.R = np.identity(3)
        self.W = np.zeros(3)

        # Desired states
        self.xd = np.zeros(3)
        self.xd_dot = np.zeros(3)
        self.xd_2dot = np.zeros(3)
        self.xd_3dot = np.zeros(3)
        self.xd_4dot = np.zeros(3)

        self.b1d = np.zeros(3)
        self.b1d[0] = 1.0
        self.b1d_dot = np.zeros(3)
        self.b1d_2dot = np.zeros(3)

        self.Wd = np.zeros(3)
        self.Wd_dot = np.zeros(3)

        self.Rd = np.identity(3)

        self.b3d = np.zeros(3)
        self.b3d_dot = np.zeros(3)
        self.b3d_2dot = np.zeros(3)

        self.b1c = np.zeros(3)
        self.wc3 = 0.0
        self.wc3_dot = 0.0

        # Flag to enable/disable integral control 
        self.use_integral = False

        self.e1 = np.zeros(3)
        self.e1[0] = 1.0
        self.e2 = np.zeros(3)
        self.e2[1] = 1.0
        self.e3 = np.zeros(3)
        self.e3[2] = 1.0

        self.m = 1.95  # Mass of the rover (kg)
        self.g = 9.81  # Gravitational acceleration (m/s^2)
        self.c_tf = 0.0135  # Torsional moment generated by the propellers
        self.l = 0.23  # Length of the rover arm (m)
        self.J = np.diag([0.02, 0.02, 0.04])  # Inertia matrix of the rover

        # Attitude gains
        self.kR = np.diag([1.6, 1.6, 0.6])  # Attitude gains
        self.kW = np.diag([0.40, 0.40, 0.10])  # Angular rate gains

        self.ky = self.kR[2, 2]  # Yaw gain for decoupled-yaw controller
        self.kwy = self.kR[2, 2]  # Yaw angular rate gain for decoupled-yaw 
            # controller

        # Position gains
        self.kX = np.diag([16.0, 16.0, 20.0])  # Position gains
        self.kV = np.diag([12.0, 12.0, 12.0])  # Velocity gains

        # Integral gains
        self.kIR = 0.015  # Attitude integral gain
        self.ki = 0.01  # Position integral gain
        self.kI = 0.01  # Attitude integral gain for roll and pitch
        self.kyI = 0.02  # Attitude integral gain for yaw
        self.kIX = 4.0  # Position integral gains
        self.c1 = 1.0  # Parameters for decoupled-yaw integral control
        self.c2 = 1.0  # Parameters for decoupled-yaw integral control
        self.c3 = 1.0  # Parameters for decoupled-yaw integral control

        self.fM = np.zeros((4, 1))  # Force-moment vector
        self.f_total = 0.0  # Calculated forces required by each moter

        fM_to_forces = np.array([
            [1.0, 1.0, 1.0, 1.0],
            [0.0, -self.l, 0.0, self.l],
            [self.l, 0.0, -self.l, 0.0],
            [-self.c_tf, self.c_tf, -self.c_tf, self.c_tf]
        ])
        self.fM_to_forces_inv = np.linalg.inv(fM_to_forces)  # Force to 
            # force-moment conversion matrix

        # Control errors
        self.ex = np.zeros(3)
        self.ev = np.zeros(3)
        self.eR = np.zeros(3)
        self.eW = np.zeros(3)
        
        # Integral errors
        self.eIX = IntegralErrorVec3()  # Position integral error
        self.eIR = IntegralErrorVec3()  # Attitude integral error
        self.eI1 = IntegralError()  # Attitude integral error for roll axis
        self.eI2 = IntegralError()  # Attitude integral error for pitch axis
        self.eIy = IntegralError()  # Attitude integral error for yaw axis

        self.sat_sigma = 1.8

        self.is_landed = True
        self.mode = 0
        self.motor_on = False

        self.init_subscribers()
        self.init_publishers()


    def control_run(self):
        """Run the controller to get the force-moments required to achieve the 
        the desired states from the current state.

        Args:
            state: (x, v, a, R, W) current states of the UAV
            desired: (xd, xd_dot, xd_2dot, xd_3dot, xd_4dot, b1d, b1d_dot,
                b1d_2dot, is_landed) desired states of the UAV

        Return:
            fM: (4x1 numpy array) force-moments vector
        """

        # If the UAV is landed, do not run the controller and produce zero
        # force-moments.
        if self.is_landed:
            self.fM = np.zeros(4)
        else: 
            self.position_control()
            self.attitude_control()

        if (not self.motor_on) or (self.mode < 2):
            force = Vector3(x=0.0, y=0.0, z=0.0)
            torque = Vector3(x=0.0, y=0.0, z=0.0)    
        else:
            # FDCL uses NED, Gazebo uses NWU
            force = Vector3(x=0.0, y=0.0, z=self.fM[0])
            torque = Vector3(x=self.fM[1], y=-self.fM[2], z=-self.fM[3])

        
        fM_message = WrenchStamped()
        fM_message.wrench.force = force
        fM_message.wrench.torque = torque

        self.pub_fM.publish(fM_message)

        self.publish_desired()
        self.publish_errors()


    def position_control(self):
        """Position controller to determine desired attitude and angular rates
        to achieve the deisred states.

        This uses the controller defined in "Control of Complex Maneuvers
        for a Quadrotor UAV using Geometric Methods on SE(3)"
        URL: https://arxiv.org/pdf/1003.2005.pdf
        """

        m = self.m
        g = self.g
        e3 = self.e3

        kX = self.kX
        kV = self.kV
        kIX = self.kIX

        R = self.R
        R_T = self.R.T

        x = self.x
        v = self.v
        W = self.W

        b1d = self.b1d
        b1d_dot = self.b1d_dot
        b1d_2dot = self.b1d_2dot
        
        xd = self.xd
        xd_dot = self.xd_dot
        xd_2dot = self.xd_2dot
        xd_3dot = self.xd_3dot
        xd_4dot = self.xd_4dot

        self.update_current_time()
        self.dt = self.t - self.t_pre

        # Translational error functions
        eX = x - xd  # position error - eq (11)
        eV = v - xd_dot  # velocity error - eq (12)

        # Position integral terms
        if self.use_integral:
            self.eIX.integrate(self.c1 * eX + eV, self.dt)  # eq (13)
            self.eIX.error = saturate(self.eIX.error, \
                -self.sat_sigma, self.sat_sigma)
        else:
            self.eIX.set_zero()

        # Force 'f' along negative b3-axis - eq (14)
        # This term equals to R.e3
        A = - kX @ eX \
            - kV @ eV \
            - kIX * self.eIX.error \
            - m * g * e3 \
            + m * xd_2dot

        hatW = hat(W)

        b3 = R @ e3
        b3_dot = R @ hatW @ e3  # eq (22)
        f_total = -A @ b3

        # Intermediate terms for rotational errors
        ea = g * e3 \
            - f_total / m * b3 \
            - xd_2dot
        A_dot = - kX @ eV \
            - kV @ ea \
            + m * xd_3dot

        fdot = - A_dot @ b3 \
            - A @ b3_dot
        eb = - fdot / m * b3 \
            - f_total / m * b3_dot \
            - xd_3dot
        A_2dot = - kX @ ea \
            - kV @ eb \
            + m * xd_4dot

        b3c, b3c_dot, b3c_2dot = deriv_unit_vector(-A, -A_dot, -A_2dot)

        hat_b1d = hat(b1d)
        hat_b1d_dot = hat(b1d_dot)

        A2 = -hat_b1d @ b3c
        A2_dot = - hat_b1d_dot @ b3c - hat_b1d @ b3c_dot
        A2_2dot = - hat(b1d_2dot) @ b3c \
            - 2.0 * hat_b1d_dot @ b3c_dot \
            - hat_b1d @ b3c_2dot

        b2c, b2c_dot, b2c_2dot = deriv_unit_vector(A2, A2_dot, A2_2dot)

        hat_b2c = hat(b2c)
        hat_b2c_dot = hat(b2c_dot)

        b1c = hat_b2c @ b3c
        b1c_dot = hat_b2c_dot @ b3c + hat_b2c @ b3c_dot
        b1c_2dot = hat(b2c_2dot) @ b3c \
            + 2.0 * hat_b2c_dot @ b3c_dot \
            + hat_b2c @ b3c_2dot

        Rd = np.vstack((b1c, b2c, b3c)).T
        Rd_dot = np.vstack((b1c_dot, b2c_dot, b3c_dot)).T
        Rd_2dot = np.vstack((b1c_2dot, b2c_2dot, b3c_2dot)).T

        Rd_T = Rd.T
        Wd = vee(Rd_T @ Rd_dot)

        hat_Wd = hat(Wd)
        Wd_dot = vee(Rd_T @ Rd_2dot - hat_Wd @ hat_Wd)

        self.f_total = f_total
        self.Rd = Rd
        self.Wd = Wd
        self.Wd_dot = Wd_dot

        # Roll / pitch
        self.b3d = b3c
        self.b3d_dot = b3c_dot
        self.b3d_2dot = b3c_2dot

        # Yaw
        self.b1c = b1c
        self.wc3 = e3 @ (R_T @ Rd @ Wd)
        self.wc3_dot = e3 @ (R_T @ Rd @ Wd_dot) \
            - e3 @ (hatW @ R_T @ Rd @ Wd)
        
        self.ex = eX
        self.ev = eV


    def attitude_control(self):
        """Deacouple-yaw attitude controller to achieve the desired attitude and
        angular rates.
        
        This uses the controller defined in "Geometric Controls of a Quadrotor
        with a Decoupled Yaw Control" 
        URL: https://doi.org/10.23919/ACC.2019.8815189
        """

        R = self.R
        R_T = self.R.T

        Rd = self.Rd
        Rd_T = self.Rd.T

        b3d = self.b3d
        b3d_dot = self.b3d_dot
        b3d_2dot = self.b3d_2dot

        W = self.W
        Wd = self.Wd

        J = self.J
        
        b1 = R @ self.e1
        b2 = R @ self.e2
        b3 = R @ self.e3

        hat_b3 = hat(b3)

        # Roll/pitch angular velocity vector
        W_12 = W[0] * b1 + W[1] * b2
        b3_dot = hat(W_12) @ b3  # eq (26)

        hat_b3d = hat(b3d)
        W_12d = hat_b3d @ b3d_dot
        W_12d_dot = hat_b3d @ b3d_2dot

        eb = hat_b3d @ b3  # eq (27)
        ew = W_12 + hat_b3 @ hat_b3 @ W_12d  # eq (28)

        # Yaw
        ey = -b2 @ self.b1c
        ewy = W[2] - self.wc3

        # Attitude integral terms
        eI = ew + self.c2 * eb

        self.eI1.integrate(eI @ b1, self.dt)  # b1 axis - eq (29)
        self.eI2.integrate(eI @ b2, self.dt)  # b2 axis - eq (30)
        self.eIy.integrate(ewy + self.c3 * ey, self.dt)

        # Control moment for the roll/pitch dynamics - eq (31)
        tau = -self.kR[0, 0] * eb \
            - self.kW[0, 0] * ew \
            - J[0, 0] * b3.T @ W_12d * b3_dot \
            - J[0, 0] * hat_b3 @ hat_b3 @ W_12d_dot
        if self.use_integral:
            tau += -self.kI * self.eI1.error * b1 \
                - self.kI * self.eI2.error * b2

        # Control moment around b1 axis - roll - eq (24)
        M1 = b1.T @ tau + J[2, 2] * W[2] * W[1]

        # Control moment around b2 axis - pitch - eq (24)
        M2 = b2.T @ tau - J[2, 2] * W[2] * W[0]

        # Control moment around b3 axis - yaw - eq (52)
        M3 = - self.ky * ey \
            - self.kwy * ewy \
            + self.J[2, 2] * self.wc3_dot
        
        if self.use_integral:
            M3 += - self.kyI * self.eIy.error

        M = np.array([M1, M2, M3])

        self.fM[0] = self.f_total
        for i in range(3):
            self.fM[i + 1] = M[i]
            
        f_motor = self.fM_to_forces_inv @ self.fM

        # For saving:
        RdtR = Rd_T @ R
        self.eR = 0.5 * vee(RdtR - RdtR.T)
        self.eIR.error = np.array([self.eI1.error, self.eI2.error, \
            self.eIy.error])
        self.eW = W - R_T @ Rd @ Wd

        # self.get_logger().info('eR ' + str(self.eR))


    def set_integral_errors_to_zero(self):
        """Set all integrals to zero."""
        self.eIX.set_zero()
        self.eIR.set_zero()
        self.eI1.set_zero()
        self.eI2.set_zero()
        self.eIy.set_zero()
        self.eIX.set_zero()


    def update_current_time(self):
        """Update the current time since epoch."""
        self.t_pre = self.t

        t_now = self.get_clock().now()
        self.t = float((t_now - self.t0).nanoseconds) * 1e-9
    


    def init_publishers(self):
        self.pub_desired = self.create_publisher(DesiredData, '/uav/desired', 1)
        self.pub_errors = self.create_publisher(ErrorData, '/uav/errors', 1)
        self.pub_fM = self.create_publisher(WrenchStamped, '/uav/fm', 1)

        timer_period = 0.005
        self.timer = self.create_timer(timer_period, self.control_run)
    

    def init_subscribers(self):
        self.sub_trajectory = self.create_subscription( \
            StateData,
            '/uav/states', 
            self.states_callback, 
            1)
        
        self.sub_trajectory = self.create_subscription( \
            DesiredData,
            '/uav/trajectory', 
            self.trajectory_callback, 
            1)
        
        self.sub_mode = self.create_subscription( \
            ModeData,
            '/uav/mode',
            self.mode_callback,
            1)
        

        self.sub_motors_on = self.create_subscription( \
            Bool,
            '/uav/motors_on',
            self.motors_on_callback,
            1)
    

    def mode_callback(self, msg):
        if self.mode == msg.mode:
            return
        
        self.mode = msg.mode
        self.get_logger().info('Mode switched to {}'.format(self.mode))

    
    def states_callback(self, msg):

        for i in range(3):
            self.x[i] = msg.position[i]
            self.v[i] = msg.velocity[i]
            self.a[i] = msg.acceleration[i]
            self.W[i] = msg.angular_velocity[i]

            for j in range(3):
                self.R[i, j] = msg.attitude[3*i + j]


    def trajectory_callback(self, msg):
        """Callback function for the trajectory subscriber.

        Args:
            msg: (DesiredData) Trajectory data message
        """

        for i in range(3):
            self.xd[i] = msg.position[i]
            self.xd_dot[i] = msg.velocity[i]
            self.xd_2dot[i] = msg.acceleration[i]
            self.xd_3dot[i] = msg.jerk[i]
            self.xd_4dot[i] = msg.snap[i]

            self.b1d[i] = msg.b1[i]
            self.b1d_dot[i] = msg.b1_dot[i]
            self.b1d_2dot[i] = msg.b1_2dot[i]

        self.is_landed = msg.is_landed

    
    def motors_on_callback(self, msg):
        self.motor_on = msg.data

        if self.motor_on:
            self.get_logger().info('Turning motors on')
        else:
            self.get_logger().info('Turning motors off')

    
    def publish_desired(self):
        """Publish the desired states."""

        msg = DesiredData()

        for i in range(3):
            msg.position[i] = self.xd[i]
            msg.velocity[i] = self.xd_dot[i]
            msg.acceleration[i] = self.xd_2dot[i]
            msg.jerk[i] = self.xd_3dot[i]
            msg.snap[i] = self.xd_4dot[i]

            msg.b1[i] = self.b1d[i]
            msg.b1_dot[i] = self.b1d_dot[i]
            msg.b1_2dot[i] = self.b1d_2dot[i]

            msg.angular_velocity[i] = self.Wd[i]
            msg.angular_acceleration[i] = self.Wd_dot[i]
            # msg.angular_jerk = self.Wd_2dot

            msg.b1c[i] = self.b1c[i]

            msg.b3[i] = self.b3d[i]
            msg.b3_dot[i] = self.b3d_dot[i]
            msg.b3_2dot[i] = self.b3d_2dot[i]

            for j in range(3):
                msg.attitude[3*i + j] = self.Rd[i, j]

        msg.wc3 = self.wc3
        msg.wc3_dot = self.wc3_dot
        
        msg.is_landed = self.is_landed

        self.pub_desired.publish(msg)


    def publish_errors(self):

        msg = ErrorData()

        for i in range(3):
            msg.position[i] = self.ex[i]
            msg.velocity[i] = self.ev[i]

            msg.attitude[i] = self.eR[i]
            msg.angular_velocity[i] = self.eW[i]

            msg.position_integral[i] = self.eIX.error[i]
            msg.attitude_integral[i] = self.eIR.error[i]
            

        self.pub_errors.publish(msg)


def main(args=None):
    print("Starting control node")

    rclpy.init(args=args)

    control = ControlNode()

    try:
        rclpy.spin(control)
    except KeyboardInterrupt:
        pass

    # Destroy the node explicitly
    # (optional - otherwise it will be done automatically
    # when the garbage collector destroys the node object)
    control.destroy_node()
    
    print("Terminating control node")
